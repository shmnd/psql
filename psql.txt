SQL 

To exit terminal
	
	\q

To get all db 

	\l

To get all tables in db 

	\dt

To enter into a db

	dt persons

To delete a table form db

	drop table person

To enter into db
	
	\c test

Create table 

	create table students(id bigserial not null primary key , name varchar(25),age int, place varchar(50));


Update with foreign key 
	brototype=# update students set domain=languages.id from languages where students.name in ('ajana','amal','razak','rahees','sameel') and languages.domain='flutter';
UPDATE 4

Delete a column from a table 

	brototype=# ALTER TABLE students DROP COLUMN domain;
ALTER TABLE


                ///////////////////////////////////////////    TASK 1     ////////////////////////////////////////////////////



concat(join 2 columns)
	select concat(fname,' ',lname) as fullname from worker;
				fullname
			-----------------
			monika arora
			niharika arora
			vishal singhal
			amithab singh
			vivek bhati
			vipul diwan
			sathish kumar
			deepika chauhan
(8 rows)


ascending and descending


	select * from worker order by fname asc;



rite an SQL query to print all Worker details from the Worker table order by FIRST_NAME Ascending and DEPARTMENT Descending.


	select * from worker order by fname asc, department des;


to find customers name end with a (LIKE OPERATOR)
	
	select fname from worker where fname like '%a';
			fname
			----------
			monika
			niharika
			deepika
		(it will give fname ending with 'a')

to find customers name start with v 

	select * from worker where fname like 'v%';


			id | fname  |  lname  | salary |   jdate    | department
			----+--------+---------+--------+------------+------------
			3 | vishal | singhal | 300000 | 2019-06-03 | hr
			5 | vivek  | bhati   | 500000 | 2019-06-05 | admin
			6 | vipul  | diwan   | 200000 | 2019-06-14 | account


			INSTEAD OF USING 'LIKE' WE ALSO CAN USER 'ILIKE'
				
				ILIKE operatoter helps avode case sensitive that means it show capital and small letters as output 
			LIKE operator is case sensitive 



Write an SQL query to print details of the Workers whose FIRST_NAME contains ‘a’

	select * from worker where fname ilike '%a%';

			id |  fname   |  lname  | salary |   jdate    | department
			----+----------+---------+--------+------------+------------
			1 | monika   | arora   | 100000 | 2019-06-08 | hr
			2 | niharika | arora   |  80000 | 2019-06-08 | admin
			3 | vishal   | singhal | 300000 | 2019-06-03 | hr
			4 | amithab  | singh   | 500000 | 2019-06-04 | admin
			7 | sathish  | kumar   |  75000 | 2019-06-14 | account
			8 | deepika  | chauhan |  90000 | 2019-06-21 | admin



   Write an SQL query to fetch worker names with salaries >= 50000 and <= 100000.

		select * from worker where salary >= 50000 and salary <= 100000;

		   id |  fname   |  lname  | salary |   jdate    | department
		  ----+----------+---------+--------+------------+------------
			1 | monika   | arora   | 100000 | 2019-06-08 | hr
			2 | niharika | arora   |  80000 | 2019-06-08 | admin
			7 | sathish  | kumar   |  75000 | 2019-06-14 | account
			8 | deepika  | chauhan |  90000 | 2019-06-21 | admin



Write an SQL query to fetch the first 50% records from a table.

	SELECT * FROM worker LIMIT (SELECT COUNT(*)/2 FROM WORKER);


			id |  fname   |  lname  | salary |   jdate    | department
			----+----------+---------+--------+------------+------------
			1 | monika   | arora   | 100000 | 2019-06-08 | hr
			2 | niharika | arora   |  80000 | 2019-06-08 | admin
			3 | vishal   | singhal | 300000 | 2019-06-03 | hr
			4 | amithab  | singh   | 500000 | 2019-06-04 | admin



Write an SQL query to show the last record from a table

	SELECT * FROM worker ORDER BY id DESC LIMIT 1;

		id |  fname  |  lname  | salary |   jdate    | department
		----+---------+---------+--------+------------+------------
		8 | deepika | chauhan |  90000 | 2019-06-21 | admin


 Swapping the Values of first name and last name Columns in a worker table

	UPDATE worker SET fname = CASE WHEN fname IS NOT NULL THEN lname ELSE NULL END, lname= CASE WHEN lname IS NOT  NULL THEN fname ELSE NULL END;



	                    ///////////////////////////////////////////////////     	TASK 2         ////////////////////////////////////////////////////////




	insert into employee(fname,lname,department,salary) values ('karan','mehta','hr',300000),('rohit','sharma','admin',75000),('ankush','rajput','account',60000),('priyadarshini','sharma','hr',500000),('sanket','gupta','developer',100000),('shruthi','varyar','admin',80000),('rohit','sharma','admin',75000);


			INSERT 0 7
			assignments=# select * from employee;
			id |     fname     | lname  | department | salary
			----+---------------+--------+------------+--------
			1 | karan         | mehta  | hr         | 300000
			2 | rohit         | sharma | admin      |  75000
			3 | ankush        | rajput | account    |  60000
			4 | priyadarshini | sharma | hr         | 500000
			5 | sanket        | gupta  | developer  | 100000
			6 | shruthi       | varyar | admin      |  80000
			7 | rohit         | sharma | admin      |  75000



	Write a query to find the three highest salary from the EmployeeInfo table ?

		select * from employee order by salary desc limit 3;

				id |     fname     | lname  | department | salary
			----+---------------+--------+------------+--------
				4 | priyadarshini | sharma | hr         | 500000
				1 | karan         | mehta  | hr         | 300000
				5 | sanket        | gupta  | developer  | 100000



	Write a query to find the third highest salary from the EmployeeInfo table ?

		select * from employee order by salary desc limit 1 offset 2;

			 id | fname  | lname | department | salary
			----+--------+-------+------------+--------
			  5 | sanket | gupta | developer  | 100000


	Write a query to find the third highest salary from the table without using TOP/LIMIT keyword ?

			SELECT MAX(salary) AS third_highest_salary
			FROM EmployeeInfo
			WHERE salary NOT IN (
				SELECT DISTINCT salary
				FROM EmployeeInfo
				ORDER BY salary DESC
				LIMIT 2
);


	Write a query to find the duplicate row in a table 

		select department ,count(*) from employee group by department having count(*) > 1;



	Write a query to display the first and last record from the EmployeeInfo table ?
	
		select * from employee order by id limit 1;

		select * from employee order by id desc limit 1;


	Write a query to calculate the even and odd records from a table ?

		select * from employee where id%2=0;

		select * from employee where id%2=1;


	How do you copy all rows of a table using query 
		
		insert into test select * from employee;

		assignments=# select * from test;
		id |     fname     | lname  | department | salary
		----+---------------+--------+------------+--------
		1 | karan         | mehta  | hr         | 300000
		2 | rohit         | sharma | admin      |  75000
		3 | ankush        | rajput | account    |  60000
		4 | priyadarshini | sharma | hr         | 500000
		5 | sanket        | gupta  | developer  | 100000
		6 | shruthi       | varyar | admin      |  80000
		7 | rohit         | sharma | admin      |  75000
		(7 rows)


		assignments=# select * from employee;
		id |     fname     | lname  | department | salary
		----+---------------+--------+------------+--------
		1 | karan         | mehta  | hr         | 300000
		2 | rohit         | sharma | admin      |  75000
		3 | ankush        | rajput | account    |  60000
		4 | priyadarshini | sharma | hr         | 500000
		5 | sanket        | gupta  | developer  | 100000
		6 | shruthi       | varyar | admin      |  80000
		7 | rohit         | sharma | admin      |  75000



Write a query to retrieve the list of employees working in the same department ?


	SELECT 
	e1.id AS emp1_id, 
	e1.fname AS emp1_fname, 
	e1.lname AS emp1_lname, 
	e1.department AS emp1_department,
	e2.id AS emp2_id,
	e2.fname AS emp2_fname,
	e2.lname AS emp2_lname,
	e2.department AS emp2_department
	FROM 
	employee e1
	JOIN 
	employee e2 ON e1.department = e2.department AND e1.id < e2.id;



	Write a query to retrieve the last 3 records from the EmployeeInfo table ?


		 select * from employee order by id desc limit 3;
				id |  fname  | lname  | department | salary
				----+---------+--------+------------+--------
				7 | rohit   | sharma | admin      |  75000
				6 | shruthi | varyar | admin      |  80000
				5 | sanket  | gupta  | developer  | 100000
				(3 rows)
						

	Write a query to fetch details of an employee whose EmpLname ends with an alphabet ‘A’ and contains five alphabets ?
		SELECT * FROM employee WHERE LENGTH(fname)=5 AND LOWER(RIGHT(fname,1))='a';






         ///////////////////////////////////////////////////////        advanced topic         //////////////////////////////////////////////////////////////////////


		   
min,max,avg
primary key relationship foreign key
join to get count of each car maker
update salary by 10 %
Copy a Table
view
case
loop
exit
continue
clustered index
non cluster index
stored procedure
normalisation
normal forms 
contstraints 
merit and demerit of db 
why db 

                          /////////////////////////////////////////////     LOOPS      ////////////////////////////////////////////////////


		There is 3 kind loop in psql :-

				1.FOR ... IN ... LOOP:


						DO $$ 
						DECLARE
							emp_record record;
						BEGIN
							FOR emp_record IN SELECT * FROM employee WHERE id BETWEEN 4 AND 10 LOOP
								-- Do something with the fetched data
X								RAISE NOTICE 'ID: %, Name: %, Salary: %', emp_record.id, emp_record.fname, emp_record.salary;
							END LOOP;
						END $$;



									output:-

									NOTICE:  ID: 4, Name: priyadarshini, Salary: 500000
									NOTICE:  ID: 5, Name: sanket, Salary: 100000
									NOTICE:  ID: 6, Name: shruthi, Salary: 80000
									NOTICE:  ID: 7, Name: rohit, Salary: 75000




				2.WHILE LOOP:


							DO $$ 
							DECLARE
								emp_id INT := 4;
								emp_record record;
							BEGIN
								WHILE emp_id <= 10 LOOP
									-- Fetch data into variables
									SELECT * INTO emp_record FROM employee WHERE id = emp_id;

									-- Do something with the fetched data
									RAISE NOTICE 'ID: %, Name: %, Salary: %', emp_record.id, emp_record.fname, emp_record.salary;

									-- Increment the counter
									emp_id := emp_id + 1;
								END LOOP;
							END $$;


											output:-

											NOTICE:  ID: 4, Name: priyadarshini, Salary: 500000
											NOTICE:  ID: 5, Name: sanket, Salary: 100000
											NOTICE:  ID: 6, Name: shruthi, Salary: 80000
											NOTICE:  ID: 7, Name: rohit, Salary: 75000
											NOTICE:  ID: <NULL>, Name: <NULL>, Salary: <NULL>
											NOTICE:  ID: <NULL>, Name: <NULL>, Salary: <NULL>
											NOTICE:  ID: <NULL>, Name: <NULL>, Salary: <NULL>


				3.Additionally, it's worth mentioning that the LOOP construct itself can be used as an infinite loop, and you can use EXIT statements to break out of the loop based on certain conditions.Example of an infinite loop with LOOP and EXIT:


							DO $$ 
							DECLARE
								emp_id INT := 4;
								emp_record record;
							BEGIN
								LOOP
									-- Fetch data into variables
									SELECT * INTO emp_record FROM employee WHERE id = emp_id;

									-- Exit the loop if the employee doesn't exist
									IF NOT FOUND THEN
										EXIT;
									END IF;

									-- Do something with the fetched data
									RAISE NOTICE 'ID: %, Name: %, Salary: %', emp_record.id, emp_record.fname, emp_record.salary;

									-- Increment the counter
									emp_id := emp_id + 1;
								END LOOP;
							END $$;


											output:-


											NOTICE:  ID: 4, Name: priyadarshini, Salary: 500000
											NOTICE:  ID: 5, Name: sanket, Salary: 100000
											NOTICE:  ID: 6, Name: shruthi, Salary: 80000
											NOTICE:  ID: 7, Name: rohit, Salary: 75000



Copy a Table into another table
	
	insert into test select * from employee;


			assignments=# select * from test;
			id |     fname     | lname  | department | salary
			----+---------------+--------+------------+--------
			1 | karan         | mehta  | hr         | 330000
			2 | rohit         | sharma | admin      |  82500
			3 | ankush        | rajput | account    |  66000
			4 | priyadarshini | sharma | hr         | 550000
			5 | sanket        | gupta  | developer  | 110000
			6 | shruthi       | varyar | admin      |  88000
			7 | rohit         | sharma | admin      |  82500


AVERAGE (AVG)

			assignments=# select avg(salary) as average_wage from aim;
				average_wage
			---------------------
			205700.000000000000
			(1 row)


MINIMUM (MIN)

			assignments=# select min(salary) as minimum from employee;
			minimum
			---------
			66000
			(1 row)


MAXIMUM (MAX)

			assignments=# select max(salary) as minimum from employee;
			minimum
			---------
			550000
			(1 row)


VIEW

	In SQL, a view is a virtual table that contains data from one or more tables. It contains a set of predefined SQL queries to fetch data from the database

	CREATE VIEW SUMMERY_VIEW AS SELECT MIN(salary) as minsalary , MAX(salary) as maxsalary, AVG(salary) as avgsalary from aim;

		CREATE VIEW

		 select * from summery_view;	
 
				minsalary | maxsalary |      avgsalary
				-----------+-----------+---------------------
					72600 |    605000 | 205700.000000000000
				(1 row)



The SQL CASE Expression


		The CASE expression goes through conditions and returns a value when the first condition is met (like an if-then-else statement). So, once a condition is true, it will stop reading and return the result. If no conditions are true, it returns the value in the ELSE clause.
		If there is no ELSE part and no conditions are true, it returns NULL.


				assignments=# SELECT fname,salary,department,
				assignments-# CASE
				assignments-#   WHEN salary >=95000 THEN 'high incomed person'
				assignments-#   WHEN department = 'admin' THEN 'the admins'
				assignments-#   ELSE 'No high income and admins'
				assignments-# END AS toppers
				assignments-# FROM employee;



							fname     | salary | department |          toppers
						---------------+--------+------------+---------------------------
						karan         | 330000 | hr         | high incomed person
						rohit         |  82500 | admin      | the admins
						ankush        |  66000 | account    | No high income and admins
						priyadarshini | 550000 | hr         | high incomed person
						sanket        | 110000 | developer  | high incomed person
						shruthi       |  88000 | admin      | the admins
						rohit         |  82500 | admin      | the admins



EXIT 
		In SQL, the EXIT statement is used to exit a loop conditionally. This means that when a specific condition is met, the loop will stop executing, and the control will be passed to the next line of code after the loop. 
		The EXIT statement can also be used to exit the current iteration of a loop, either conditionally or unconditionally. It transfers control to the end of either the current loop or an enclosing labeled loop. 
		The EXIT statement must be inside a LOOP statement. When the EXIT statement is encountered inside a loop, the loop is immediately terminated and the program control resumes at the next statement following the loop. 
		The EXIT statement is used for terminating the execution, especially while working with loops and nested loops


				DO $$ 
				DECLARE
					emp_id INT := 4;
					emp_record record;
				BEGIN
					LOOP
						-- Fetch data into variables
						SELECT * INTO emp_record FROM employee WHERE id = emp_id;

						-- Exit the loop if the employee doesn't exist
						IF NOT FOUND THEN
							EXIT;
						END IF;

						-- Do something with the fetched data
						RAISE NOTICE 'ID: %, Name: %, Salary: %', emp_record.id, emp_record.fname, emp_record.salary;

						-- Increment the counter
						emp_id := emp_id + 1;
					END LOOP;
				END $$;


								output:-


								NOTICE:  ID: 4, Name: priyadarshini, Salary: 500000
								NOTICE:  ID: 5, Name: sanket, Salary: 100000
								NOTICE:  ID: 6, Name: shruthi, Salary: 80000
								NOTICE:  ID: 7, Name: rohit, Salary: 75000

'CONTINUE' Statement


		When the SQL engine encounters a 'CONTINUE' statement, it ends the current loop iteration and immediately jumps to the beginning of the next iteration. Important to note, the 'CONTINUE' statement is only valid for use inside loops.

